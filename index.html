<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <script src="https://unpkg.com/vue"></script>
    <style>
      body, html, #container{
        width: 100%;
        height: 100%;
        overflow:hidden;
        position:absolute;
        margin:0;
        transform:translate(0,0);
        background-color:black;
        color:white;
        font-family:sans-serif;
      }
      .entity {
        position: absolute;
        left:50%;
        top:50%;
        cursor:default;
        user-select:none;
      }
      @keyframes bounce {
        0%, 100% {margin-top: 0;}
        50% {margin-top: -4px;}
      }
      @keyframes collectme {
        0% {text-shadow:white 1px -1px,white -1px 1px,white -1px -1px,white 1px 1px;}
        100% {text-shadow:black 3px -3px,black -3px 3px,black -3px -3px,black 3px 3px;}
      }
      .item{
        animation:collectme 1.5s infinite;
      }
      .hud{
        left:0;
        right:0;
        position:absolute;
        text-align:center;
        bottom:0;
        font-size:16px;
      }
      .ability{
        display:inline-block;
        width:60px;
        height:60px;
        padding:15px 10px 5px 10px;
        font-size:40px;
      }
      .foliage{
        font-size:3em;
      }
      .abilitydesc{margin:5px 0 -5px 0;}
      .health{font-size:30px;}
      .text{font-size:0.75em;background-color:rgba(0,0,0,0.7);padding:3px;text-align:center;}
    </style>
  </head>
  <body>
    <div id="container" :style="{'font-size':gridSize+'px'}">
      <entity v-for="item in world.items" :time="world.time" :entity="item" :kind="item" :class="{'item':!item.collected}" :key="item.id"></entity>
      <entity v-for="foliage in world.foliage" :time="world.time" :entity="foliage" class="foliage" :key="foliage.id"></entity>
      <entity v-for="player in world.players" :time="world.time" :entity="player" :key="player.id"></entity>
      <entity v-for="enemy in world.enemies" :time="world.time" :entity="enemy" :key="enemy.id"></entity>
      <entity v-for="element in world.elements" :time="world.time" :entity="element" :key="element.id"></entity>
      <entity v-for="text in world.text" class="text" :time="world.time" :entity="text" :key="text.id"></entity>
      <section class="hud">
        <div class="health">{{healthToEmoji(player, world.time)}}</div>
        <!--<div class="abilitydesc">{{textify(player.ability)}}</div>-->
        <div v-for="index in [3,2,1,0]" class="ability">{{player.ability[index]||"â¬œ"}}</div>
      </section>
    </div>
    <script>
/* Ideas
quick ğŸš€ â© ğŸ’¨
invisible ğŸ›° ğŸŒ« â™¨
flaming ğŸ”¥ generated by ğŸŒ‹
freezing â„ï¸ generated by ğŸŒ¨
lighting âš¡ generated by ğŸŒ©
wet ğŸ’§ğŸŒŠ generated by â›²
exploding ğŸ’£ ğŸ’¥
leaf ğŸ‚ ğŸƒ ğŸŒ¿ ğŸŒ± ğŸŒ³ ğŸŒ·
beam ğŸ’¡ ğŸŒŸ
bullet ğŸŒ  ğŸ”«
multi ğŸ¶ ğŸ”€ ğŸ”
healing ğŸ’— ğŸ’– generated by ğŸ¥
protective ğŸ›¡
piercing ğŸ’˜ ğŸ¹

hitting ğŸ’¢ generated by ğŸ¥Š
homing ğŸ‘ï¸ ğŸ¯

ğŸ”‘ â›º ğŸ”” ğŸ”Š ğŸ”‹ âš“ ğŸ‡ ğŸ° ğŸ
ğŸ† ğŸ‡ ğŸ”… ğŸ”† â‡
â˜„ï¸ âœ¨ âœ´ï¸ â­ ğŸ’« ğŸ—¯ï¸ ğŸŒ€

ğŸ’”

ğŸ”³ğŸ”²

Enemy
â¬›ğŸ›¡ğŸ›¡
ğŸ›¡ğŸŒ‹ğŸ›¡
ğŸ›¡ğŸ›¡ğŸ”²
â¬›ğŸ›¡ğŸ”²ğŸ”²
â¬›ğŸ›¡ğŸ°ğŸ”²ğŸš€
â¬›ğŸ›¡ğŸ”²ğŸ”²
ğŸ›¡ğŸ›¡ğŸ”²
ğŸ›¡ğŸŒ‹ğŸ›¡
â¬›ğŸ›¡ğŸ›¡
*/

MAX_ABILITY = 4
Player = {
  new(type="ğŸ’ƒ", x=0, y=0, health=4){
    var player={
      type,x,y,
      maxHealth:health,health,regen:0,
      ability: [],//["ğŸŒ‹","ğŸŒ¿","ğŸŒ©","ğŸŒ¨"]
      cooldown: 0, frozen: 0, hurting: 0,
      id:Math.random()
    };
    world.players.push(player);
    return player;
  },
  tick(player){
    player.hurting = Math.max(0, player.hurting - 1/60);
    player.frozen = Math.max(0, player.frozen - 1/60);
    player.cooldown = Math.max(0, player.cooldown - 1/60);
    player.regen = Math.max(0, player.regen - 1/5/60);
    if(!player.hurting){
      if(player.regen<=0){player.health = Math.min(player.maxHealth,player.health+3/60)}
      else if(player.regen<0.6 && player.health<player.maxHealth/2){player.health = Math.min(player.maxHealth/2,player.health+3/60)}
    }
    if(player.frozen <= 0){
      if(player.cooldown<=0){
        if(player===window.player&&keysDown["KeyZ"]){
          // player.ability.reverse()
          var nearestEnemy = findClosest(player, world.enemies, (e)=>{
            var distanceTo = distance(e,player);
            return distanceTo<15});// && lastDx*(e.x-player.x)/distanceTo+lastDy*(e.y-player.y)/distanceTo > 0.5});
          if(nearestEnemy.length){lastDx = nearestEnemy[0].x - player.x;lastDy = nearestEnemy[0].y - player.y;}
          Element.fire(player, player.ability.join("") || "ğŸ¥Š", lastDx, lastDy, false);
          // player.ability.reverse()
        }
      }
    }
    var foliageCollisions = findClosest(player, world.foliage, (e)=>distance(player,e)<2);
    foliageCollisions.forEach((e)=>{
      var fromCenter = distance(player,e);
      player.x = 2 * (player.x - e.x) / fromCenter + e.x;
      player.y = 2 * (player.y - e.y) / fromCenter + e.y;
    })

    var fromCenter = dist(player.x, player.y);
    if(fromCenter > 85){
      player.x = 85 * player.x / fromCenter;
      player.y = 85 * player.y / fromCenter;
    }

    if(player===window.player && player.health <= 0){
      player.x = 0; player.y = 0; player.regen = 0;
      player.health = player.maxHealth; player.lastHealth = player.health;
      return true;
    }
    return player.health > 0;
  }
}

Element = {
  fire(who, props, dx, dy, hostile, generation = 1){
    if(!props)return;
    var dr = dist(dx, dy); dx/=dr; dy/=dr;
    var type = props.startsWith("ğŸŒ¿")?"ğŸ‚":props.startsWith("ğŸŒ‹")?"ğŸ”¥":props.startsWith("ğŸŒ¨")?"â„ï¸":props.startsWith("ğŸŒ©")?"âš¡":props.slice(0,2);

    var multi=0, lifespan = 0, damage = 0, speed = 0, homing=0, freezing=0, exploding=0;
    if(type=="ğŸ‚"){who.cooldown=0.75; damage=1.3*0.75;}
    if(type=="ğŸ”¥"){who.cooldown=1.2; damage=1.5*1.2;}
    if(type=="â„ï¸"){who.cooldown=0.5; damage=0.9*0.5;dx+=Math.random()*0.5-0.25;dy+=Math.random()*0.5-0.25}
    if(type=="âš¡"){who.cooldown=0.5; damage=1.1*0.5}
    if(type=="ğŸ¥Š"){lifespan = 0.4; damage = 1.5; speed = 15; who.cooldown = 1;}
    for(var p = 0; p < props.length; p+=2){
      if(props.slice(p).startsWith("ğŸŒ¿")){multi++;lifespan += 1; speed += 12;}
      if(props.slice(p).startsWith("ğŸŒ‹")){exploding++;lifespan += 13/8; speed += 8;}
      if(props.slice(p).startsWith("ğŸŒ¨")){freezing++;lifespan += 15/6; speed += 6;}
      if(props.slice(p).startsWith("ğŸŒ©")){homing++;who.cooldown*=0.8; lifespan += 10/15; speed += 15;}
    }
    var newNumber = multi?Math.pow(3, generation):1, numProps = props.length/2;
    speed*=1/numProps;
    damage*=(1 + numProps*0.1)*(1 + multi*0.8)/newNumber;
    lifespan*=(0.9 + numProps*0.1)/numProps/Math.max(1,multi);

    var offset = generation == 0?1:0;
    Element.new(type, props, who.x+offset*dx, who.y+offset*dy, dx*speed, dy*speed, hostile, lifespan, damage, multi - generation, homing, freezing, exploding, generation+1)
    if(multi > 0){
      Element.new(type, props, who.x+offset*dx, who.y+offset*dy, (dx+dy/2)*speed, (dy-dx/2)*speed, hostile, lifespan, damage, multi - generation, homing, freezing, exploding, generation+1)
      Element.new(type, props, who.x+offset*dx, who.y+offset*dy, (dx-dy/2)*speed, (dy+dx/2)*speed, hostile, lifespan, damage, multi - generation, homing, freezing, exploding, generation+1)
    }
  },
  new(type, props, x, y, dx, dy, hostile, lifespan, damage, multi, homing, freezing, exploding, generation){
    world.elements.push({type, props, x, y, dx, dy, hostile, lifespan, damage, multi, homing, freezing, exploding, generation, explosion:0});
  },
  tick(element){
    if(element.explosion>0){element.explosion-=1/20;if(element.explosion<=0){return false;};return true;}
    element.x += element.dx/60; element.y += element.dy/60;
    element.lifespan -= 1/60;
    if(element.type=="ğŸ‚"){element.dx *= 0.99; element.dy *= 0.99;}
    if(element.type=="â„ï¸"){element.dx += Math.random()*0.1-0.05; element.dy += Math.random()*0.1-0.05; }
    if(element.homing>0){
      var nearestEnemy = findClosest(element, element.hostile?world.players:world.enemies, (e)=>(element.dx)*(e.x-element.x)+(element.dy)*(e.y-element.y)>0)
      var speed = dist(element.dx, element.dy);
      if(nearestEnemy.length){
        var homingFactor = (0.4*element.homing)/(distance(element, nearestEnemy[0]));
        element.dx += (nearestEnemy[0].x - element.x)*homingFactor;
        element.dy += (nearestEnemy[0].y - element.y)*homingFactor;
        var newSpeed = dist(element.dx, element.dy);
        element.dx *= speed/newSpeed; element.dy *= speed/newSpeed;
      }
    }
    if(element.lifespan <= 0 && element.multi > 0){
      setTimeout(()=>{Element.fire(element, element.props, element.dx, element.dy, element.hostile, element.generation)}, 0);
    }
    var foliageCollisions = findClosest(element, world.foliage, (e)=>distance(e,element)<2);
    if(foliageCollisions.length > 0) {return false;}

    var collisions = findClosest(element, element.hostile?world.players:world.enemies, (e)=>distance(e,element)<1);
    collisions.forEach((other)=>Element.collide(element,other));
    if(element.explosion == 1) return true;
    return element.lifespan > 0;
  },
  collide(element, other){
    var targeted = (findClosest(element, element.hostile?world.players:world.enemies, (e)=>distance(e,element)<Math.sqrt(10*element.exploding+1)));
    if(targeted.indexOf(other)==-1){targeted.push(other)}
    targeted.forEach((e)=>{if(e!==element){if(e===window.player)e.lastHealth = e.health;e.health -= (element.exploding&&distance(e,element)>=1?0.5/Math.sqrt(10*element.exploding+1):1)*element.damage; e.hurting = 0.5; e.regen!=undefined&&(e.regen=1); e.frozen = Math.max(e.frozen, (element.hostile?1:1.5)*element.freezing);}})
    element.lifespan = 0;
    if(element.exploding){
      element.explosion = 1;
    }
  }
}

Enemy = {
  new(type, x, y, tag){
    var weaponIntermingle =
      {"ğŸ‡":[{radius:10,force:0.3},{radius:2.5,force:1},{radius:1.5,force:-4}],
       "ğŸ":[{radius:10,force:0.3},{radius:2.5,force:1},{radius:1.5,force:-4}],
       "ğŸŒ‹":[{radius:4,force:-3}],
       "ğŸŒ¨":[{radius:4,force:-3}],
       "ğŸŒ©":[{radius:4,force:-3}],
       "ğŸŒ¿":[{radius:4,force:-3}]}
    type=="ğŸ‡"?Enemy.addEnemy(type,x,y, 1.5,  1,null,{"ğŸ‡":[{radius:8,force:0.3},{radius:4,force:-0.3},{radius:2,force:-4}],"ğŸ’ƒ":[{radius:8,force:-4.5},{radius:10,force:2}]},tag):
    type=="ğŸ"?Enemy.addEnemy(type,x,y, 5,  1,null,{"ğŸ‡":[{radius:8,force:0.3},{radius:4,force:-0.3},{radius:2,force:-4}],"ğŸ":[{radius:8,force:0.3},{radius:6,force:-0.8},{radius:2,force:-4}],"ğŸ’ƒ":[{radius:4,force:-5},{radius:10,force:1.5}]},tag):
    type=="ğŸŒ‹"?Enemy.addEnemy(type,x,y,3, 2,type,weaponIntermingle,tag):
    type=="ğŸŒ¨"?Enemy.addEnemy(type,x,y,3, 2,type,weaponIntermingle,tag):
    type=="ğŸŒ©"?Enemy.addEnemy(type,x,y,3, 2,type,weaponIntermingle,tag):
    type=="ğŸŒ¿"?Enemy.addEnemy(type,x,y,3, 2,type,weaponIntermingle,tag):0;
  },
  addEnemy(type,x,y,health,speed,drops,attracts,tag){
    world.enemies.push({type,x,y,health,maxHealth:health,speed,drops,attracts,tag,dx:0,dy:0,frozen:0,cooldown:0,hurting:0,id:Math.random()})
  },
  tick(enemy){
    enemy.hurting = Math.max(0, enemy.hurting - 1/60);
    enemy.frozen = Math.max(0, enemy.frozen - 1/60);
    if(enemy.type=="ğŸ"||enemy.type=="ğŸ‡"){
      if(enemy.health < enemy.maxHealth) {
        enemy.attracts["ğŸ’ƒ"][1].radius = 20; // They're onto you now
        enemy.attracts["ğŸ’ƒ"][1].force = 2.5;
        enemy.attracts["ğŸ’ƒ"][0].radius = 3;
      }
      if(enemy.health < enemy.maxHealth/3){
        enemy.attracts["ğŸ’ƒ"][1].radius = 14; // They're onto you now
        enemy.attracts["ğŸ’ƒ"][1].force = -1;// Run!
      }
    }
    if(enemy.frozen <= 0){
      var dx = 0, dy = 0;
      world.enemies.concat(world.players).forEach((e)=>{
        var attracts;
        if(e !== enemy && (attracts = enemy.attracts[e.type])){
          var distanceTo = distance(e, enemy)
          attracts.forEach((attraction)=>{
            if(distanceTo <= attraction.radius && distanceTo > 0){
              dx += enemy.speed * attraction.force * (e.x - enemy.x) / distanceTo + 0.01*(enemy.dx - dx);
              dy += enemy.speed * attraction.force * (e.y - enemy.y) / distanceTo + 0.01*(enemy.dy - dy);
            }
          });
        }
      });
      enemy.dx = enemy.dx*0.9 + dx*0.1; enemy.dy = enemy.dy*0.9 + dy*0.1;
      enemy.x += enemy.dx/60; enemy.y += enemy.dy/60;
      if(enemy.drops&&((world.time+3.5*enemy.id)%7<3)){
        var nearestPlayer = findClosest(enemy, world.players, (e)=>distance(e,enemy)<17);
        if(nearestPlayer.length&&enemy.cooldown==0){
          var prediction = 0.25*distance(enemy, nearestPlayer[0]);
          Element.fire(enemy, enemy.type, nearestPlayer[0].x+prediction*(nearestPlayer[0].dx||0)-enemy.x,nearestPlayer[0].y+prediction*(nearestPlayer[0].dy||0)-enemy.y, true);
        }
      }
      enemy.cooldown=Math.max(0, enemy.cooldown - 1/60);
    }
    var foliageCollisions = findClosest(enemy, world.foliage, (e)=>distance(enemy,e)<2);
    foliageCollisions.forEach((e)=>{
      var fromCenter = distance(enemy,e);
      enemy.x = 2 * (enemy.x - e.x) / fromCenter + e.x;
      enemy.y = 2 * (enemy.y - e.y) / fromCenter + e.y;
    })
    var fromCenter = dist(enemy.x, enemy.y);
    if(fromCenter > 85){
      enemy.x = 85 * enemy.x / fromCenter;
      enemy.y = 85 * enemy.y / fromCenter;
    }
    if(enemy.health <= 0 && enemy.drops){
      Item.new(enemy.drops, enemy.x, enemy.y);
    }
    return enemy.health > 0;
  }
}

Item = {new(type, x, y, verb, text){world.items.push({type, x, y, verb, text, id:Math.random()})}}
Foliage = {new(type, x, y){world.foliage.push({type, x, y, id:Math.random()})}}

world = {
  "items":[],
  "players":[],
  "foliage":[],
  "enemies":[],
  "elements":[],
  "text":[{x:0,y:0,type:"",id:Math.random()}],
  "time":0
}
inactiveEnemies = [];
inactiveFoliage = [];
player = Player.new();
acquiring = false;
dropping = false;
reading=false;
inventorywarning = 0;

for(var r = 0; r < 8; r++){ var theta = Math.random() * 2 * Math.PI;
  var enemyType = ["ğŸŒ‹","ğŸŒ¨","ğŸŒ©","ğŸŒ¿"][r%4];
  Enemy.new(enemyType,r * Math.cos(theta), r * Math.sin(theta)-50, ["boss"])
}
for(var r = 1; r < 10; r+=0.5){ var theta = Math.random() * 2 * Math.PI;
  Enemy.new("ğŸ‡",r * Math.cos(theta)+1, r * Math.sin(theta)-50, ["boss"])
  Enemy.new("ğŸ",r * Math.cos(theta)-1, r * Math.sin(theta)-50, ["boss"])
}
for(var r = 13; r < 18; r+=1){ var theta = Math.random() * 2 * Math.PI;
  Enemy.new("ğŸŒ¿",r * Math.cos(theta)-50, r * Math.sin(theta), ["leaf"])
  Enemy.new("ğŸ‡",r * Math.cos(theta)-50+1, r * Math.sin(theta), ["leaf"])
}
for(var r = 13; r < 18; r+=1){ var theta = Math.random() * 2 * Math.PI;
  Enemy.new("ğŸŒ¨",r * Math.cos(theta)-30, r * Math.sin(theta)+40, ["snow"])
  Enemy.new("ğŸ‡",r * Math.cos(theta)-30+1, r * Math.sin(theta)+40, ["snow"])
  Enemy.new("ğŸ‡",r * Math.cos(theta)-30, r * Math.sin(theta)+40-1, ["snow"])
}
for(var r = 13; r < 18; r+=1){ var theta = Math.random() * 2 * Math.PI;
  Enemy.new("ğŸŒ‹",r * Math.cos(theta)+50, r * Math.sin(theta), ["volcano"])
  Enemy.new("ğŸ‡",r * Math.cos(theta)+50+1, r * Math.sin(theta), ["volcano"])
  Enemy.new("ğŸ",r * Math.cos(theta)+50, r * Math.sin(theta)+1, ["volcano"])
  Enemy.new("ğŸ",r * Math.cos(theta)+50, r * Math.sin(theta)-1, ["volcano"])
}
for(var r = 13; r < 18; r+=1){ var theta = Math.random() * 2 * Math.PI;
  Enemy.new("ğŸŒ©",r * Math.cos(theta)+30, r * Math.sin(theta)+40, ["zap"])
  Enemy.new("ğŸ",r * Math.cos(theta)+30+1, r * Math.sin(theta)+40, ["zap"])
  Enemy.new("ğŸ",r * Math.cos(theta)+30, r * Math.sin(theta)+40-1, ["zap"])
}

for(var r = 6; r < 20; r+=5){ var theta = Math.random() * 2 * Math.PI;
  Foliage.new("ğŸŒ·",Math.round(r * Math.cos(theta)), Math.round(r * Math.sin(theta)), 1)}
for(var r = 6; r < 35; r+=1){ var theta = Math.random() * 2 * Math.PI;
  Foliage.new("ğŸŒ¾",Math.round(r * Math.cos(theta)), Math.round(r * Math.sin(theta)), 1)}
for(var r = 16; r < 30; r+=1.5){ var theta = Math.random() * 2 * Math.PI;
  Foliage.new("ğŸ ",Math.round(r * Math.cos(theta))+1, Math.round(r * Math.sin(theta))-50)}
for(var r = 8; r < 20; r+=3){ var theta = Math.random() * 2 * Math.PI;
  Foliage.new("ğŸš",Math.round(r * Math.cos(theta))+1, Math.round(r * Math.sin(theta))-50)}
for(var r = 5; r < 33; r+=1.25){ var theta = Math.random() * 2 * Math.PI;
  Foliage.new("ğŸŒ³",Math.round(r * Math.cos(theta))-50, Math.round(r * Math.sin(theta)))}
for(var r = 5; r < 33; r+=1.25){ var theta = Math.random() * 2 * Math.PI;
  Foliage.new("ğŸ”ï¸",Math.round(r * Math.cos(theta))-30, Math.round(r * Math.sin(theta))+40)}
for(var r = 5; r < 33; r+=1.25){ var theta = Math.random() * 2 * Math.PI;
  Foliage.new("â›°",Math.round(r * Math.cos(theta))+50, Math.round(r * Math.sin(theta)))}
for(var r = 5; r < 33; r+=1.25){ var theta = Math.random() * 2 * Math.PI;
  Foliage.new("ğŸŒµ",Math.round(r * Math.cos(theta))+30, Math.round(r * Math.sin(theta))+40)}
for(var theta = 0; theta < Math.PI*2; theta+=0.025+Math.random()*0.025){var r = 80 + Math.random()*30;
  Foliage.new("ğŸŒŠ",Math.round(r * Math.cos(theta)), Math.round(r * Math.sin(theta)))}
Item.new("ğŸ“®", 0, -5, "ğŸ‘€", ()=>"ğŸ˜ï¸âš ï¸â˜ ï¸â¬†ï¸<br>ğŸŒ³ğŸƒğŸŒ³â¬…ï¸â¡ï¸ğŸŒ¡ï¸ğŸŒ‹â›°ï¸<br>â˜ƒï¸ğŸ”ï¸â†™ï¸â†˜ï¸ğŸŒªï¸ğŸœï¸");
Item.new("ğŸƒ", 3, 0, "ğŸ‘„", ()=>countByTag("boss")<6?"ğŸ˜ŒğŸ’¯ğŸ•Šï¸â—":"ğŸ†˜ğŸ‡ğŸğŸ’¥ğŸ˜â¬†ï¸âš ï¸â˜ ï¸ï¸â—")
Item.new("ğŸƒ", -2, -18, "ğŸ‘„", ()=>countByTag("boss")<6?"ğŸ˜ƒâ˜®ï¸âœŒï¸â—":player.ability.length<3?"ğŸ›‘ï¸âš ï¸â˜ â³ğŸ› ï¸â“â¬‡ï¸ğŸ’ƒâ¬‡ï¸":"ğŸ’ƒğŸ’ªğŸ‡ğŸğŸ’¥ğŸ˜â¬†ï¸")
Item.new("ğŸƒ", -24, 3, "ğŸ‘„", ()=>countByTag("leaf")<5?"ğŸš«ğŸ‡ğŸ‘Œ":"âš ï¸ğŸ‡ğŸ‡ğŸŒ¿ğŸ‚ğŸ‚ğŸ‚"+(player.ability.length<2?"<br>ğŸ‡¿â¡ï¸"+(player.ability.length==0?"ğŸ¥Š":"")+"ğŸ’¥ğŸ‡â˜ ï¸â©ğŸ’ƒğŸ’¨ğŸ‡¿â¡ï¸ğŸŒ¿ğŸ“¥":"<br>ğŸ‡½â¡ï¸ğŸ“¤"))
Item.new("ğŸƒ", 3, 20, "ğŸ‘„", ()=>(countByTag("snow")<14?"âš ï¸âš¡ğŸ¯â©ğŸ’ƒ":"âš ï¸â„ï¸âš“ğŸ’ƒ")+(player.ability.length<2?"<br>ğŸ‡¿â¡ï¸"+(player.ability.length==0?"ğŸ¥Š":"")+"ğŸ’¥ğŸ‡ğŸâ˜ ï¸â©ğŸ’ƒğŸ’¨ğŸ‡¿â¡ï¸"+(countByTag("snow")<14?"ğŸŒ©":"ğŸŒ¨")+"ğŸ“¥":"<br>ğŸ‡½â¡ï¸ğŸ“¤ğŸ”€ğŸ‡¿â¡ï¸ğŸ“¥"))
Item.new("ğŸƒ", 20, 2, "ğŸ‘„", ()=>(countByTag("volcano")<10?"ğŸ‡ğŸâ˜ ï¸â©ğŸŒ¡ï¸ğŸ’¯ğŸ‘":"âš ï¸ğŸ˜¡ğŸ‡ğŸâ©â™¨ğŸŒ‹ğŸ”¥â—")+"<br>"+(player.ability.length<2?"ğŸ‡¿â¡ï¸"+(player.ability.length==0?"ğŸ¥Š":"")+"ğŸ’¥ğŸ‡ğŸâ˜ ï¸â©ğŸ’ƒğŸ’¨ğŸ‡¿â¡ï¸ğŸŒ‹ğŸ“¥":"ğŸ’¡ğŸ‡½â¡ï¸ğŸ“¤ğŸ”€ğŸ“¥"))

player.lastHealth = player.maxHealth;
countByTag = function(tag){return allEnemies.filter((e)=>e.tag&&e.tag.indexOf(tag)!=-1).length}
loop = function(){
  requestAnimationFrame(loop);
  allEnemies = world.enemies.concat(inactiveEnemies);
  allFoliage = world.foliage.concat(inactiveFoliage);
  var newWorldEnemies = allEnemies.filter((e)=>Pixels.inWorldExtended(e.x,e.y));
  var newWorldFoliage = allFoliage.filter((e)=>Pixels.inWorldExtended(e.x,e.y));
  var newInactiveEnemies = allEnemies.filter((e)=>!Pixels.inWorldExtended(e.x,e.y));
  var newInactiveFoliage = allFoliage.filter((e)=>!Pixels.inWorldExtended(e.x,e.y));
  world.enemies = newWorldEnemies;
  world.foliage = newWorldFoliage;
  inactiveEnemies = newInactiveEnemies;
  inactiveFoliage = newInactiveFoliage;

  player.dx = 0; player.dy=0;
  if(player.frozen <= 0){
    var dx = (+!!keysDown["ArrowRight"]-+!!keysDown["ArrowLeft"]),
        dy = (+!!keysDown["ArrowDown"]-+!!keysDown["ArrowUp"]),
        dr = dist(dx, dy);
    if(dr > 0){
      var playerSpeed = player.cooldown==0?7:4;
      player.x+=(player.dx=lastDx=dx/dr)*playerSpeed/60
      player.y+=(player.dy=lastDy=dy/dr)*playerSpeed/60
    }
  }
  if(player.hurting <= 0){
    player.lastHealth = Math.max(player.health,0.8*player.lastHealth + 0.18*player.health);
  }
  var itemsAvailableForPickup = findClosest(player, world.items, (i)=>distance(player,i)<1.8);
  if(itemsAvailableForPickup.length>0){
    world.text[0].x = itemsAvailableForPickup[0].x;
    world.text[0].y = itemsAvailableForPickup[0].y-1.2;
    world.text[0].type = inventorywarning?"âš ï¸0ï¸âƒ£âœ–ï¸â¬œâ—<br>ğŸ‡½â¡ï¸ğŸ“¤":
                         reading?itemsAvailableForPickup[0].text&&itemsAvailableForPickup[0].text():
                         "ğŸ‡¿â¡ï¸"+(itemsAvailableForPickup[0].verb||"ğŸ“¥");
    if(keysDown["KeyZ"] && !acquiring){
      if(itemsAvailableForPickup[0].verb){ reading = true; itemsAvailableForPickup[0].collected = true;}
      else if(player.ability.length<MAX_ABILITY){
          player.ability.unshift(itemsAvailableForPickup[0].type);
          world.items.splice(world.items.indexOf(itemsAvailableForPickup[0]), 1);
      } else{ inventorywarning = true; }
    }
  }
  else{ world.text[0].type = ""; reading = false; inventorywarning = false;}

  if((keysDown["KeyX"]) && !dropping && player.ability.length){
    inventorywarning = false;
    Item.new(player.ability.shift(), player.x+1.7*Math.sin(2*Math.PI*player.ability.length/MAX_ABILITY), player.y-1.7*Math.cos(2*Math.PI*player.ability.length/MAX_ABILITY))
  }
  acquiring = !!keysDown["KeyZ"]
  dropping = !!keysDown["KeyX"]

  world.players = world.players.filter(Player.tick);
  world.elements = world.elements.filter(Element.tick);
  world.enemies = world.enemies.filter(Enemy.tick);
  world.time+=1/60;
}
keysDown = {};
window.onkeydown = function(event){keysDown[event.code] = true}
window.onkeyup = function(event){delete keysDown[event.code];}
distance = function(a,b){return dist(a.x-b.x, a.y-b.y);}
dist = function(dx, dy){return Math.sqrt(dx * dx + dy * dy);}
findClosest = function(entity, array, filter = (a)=>true){return array.filter(filter).sort((a,b)=>distance(a,entity) - distance(b,entity));}
lastDx = 0; lastDy = -1;
// textify = function(ability){
//   return (ability.slice().map((item,index)=>
//     item=="ğŸŒ¨"?(index==0?"Snowstorm":"Freezing"):
//     item=="ğŸŒ‹"?(index==0?"Fireball":"Exploding"):
//     item=="ğŸŒ¿"?(index==0?"Leaf Flurry":"Splitting"):
//     item=="ğŸŒ©"?(index==0?"Lightning Bolt":"Seeking"):"").reverse().join(" ")||"Punch")}
healthToEmoji = function(player,time){
  var emoji = "";
  for(var i = 1; i <= player.maxHealth; i++){
    emoji += Math.ceil(player.lastHealth)>=i?(
              (player.hurting>0?Math.floor:Math.ceil)(player.health)>=i?"â¤ï¸":(time%0.2<0.1||player.hurting==0)?"ğŸ’”":"ğŸ–¤"):
             "ğŸ–¤"}
  return emoji;}
gridSize = 30; // in pixels

Pixels = {
  inWorldExtended(worldUnitX, worldUnitY){
    return Math.abs(Pixels.getX(worldUnitX)) < window.innerWidth &&
           Math.abs(Pixels.getY(worldUnitY)) < window.innerHeight;
  },
  inWorld(worldUnitX, worldUnitY){
    return Math.abs(Pixels.getX(worldUnitX)) < window.innerWidth/2+2*gridSize &&
           Math.abs(Pixels.getY(worldUnitY)) < window.innerHeight/2+2*gridSize;
  },
  getX(worldUnitX){return gridSize * (worldUnitX - player.x);},
  getY(worldUnitY){return gridSize * (worldUnitY - player.y);}
}
Vue.component("entity", {
  props: ["entity", "time"],
  methods: {
    getX: Pixels.getX,getY: Pixels.getY,inWorld: Pixels.inWorld
  },
  template: `
    <div class="entity"
      v-if="entity.type && inWorld(entity.x, entity.y)"
      :style="{
        opacity:entity.explosion&&entity.explosion>0?entity.explosion:entity.hurting>0&&entity.hurting%0.2<0.1?0.3:entity.frozen&&entity.frozen>0?0.7:1,
        transform:'translate('+getX(entity.x)+'px,'+getY(entity.y)+'px) translate(-50%, -50%)'+(entity.explosion&&entity.explosion>0?' scale('+(4-3*entity.explosion)+')':'')
      }" v-html="entity.type">
    </div>
  `
})

game = new Vue({
  el: "#container",
  data: {
    world, player, gridSize
  },
  methods: {healthToEmoji}
});

loop();
    </script>
  </body>
</html>

